#!/usr/bin/env python
"""Script to create self contained install.

The goal of this script is simple:

  * Create a self contained install of the CLI that
  has requires no external resources during installation.

It does this by using all the normal python tooling
(virtualenv, pip) but provides a simple, easy to use
interface for those not familiar with the python
ecosystem.

"""

from __future__ import print_function

import argparse
import os.path
import re
import shlex
import shutil
import subprocess
import sys
import tempfile
import zipfile


PYTHON_VERSIONS = ["2.6", "2.7", "3.3", "3.4", "3.5", "3.6"]

VIRTUALENV_VERSION = "15.1.0"


if sys.version_info[0] == 2:
    PY2 = True
    FileNotFoundError = OSError

    _find_unsafe = re.compile(r'[^\w@%+=:,./-]').search

    def shlex_quote(s):
        """Return a shell-escaped version of the string *s*."""
        if not s:
            return "''"
        if _find_unsafe(s) is None:
            return s

        # use single quotes, and put single quotes into double quotes
        # the string $'b is then quoted as '$'"'"'b'
        return "'" + s.replace("'", "'\"'\"'") + "'"

    class subprocess_CompletedProcess(object):
        """A process that has finished running.

        This is returned by run().

        Attributes:
          args: The list or str args passed to run().
          returncode: The exit code of the process, negative for signals.
          stdout: The standard output (None if not captured).
          stderr: The standard error (None if not captured).
        """
        def __init__(self, args, returncode, stdout=None, stderr=None):
            self.args = args
            self.returncode = returncode
            self.stdout = stdout
            self.stderr = stderr

        def __repr__(self):
            args = ['args={!r}'.format(self.args),
                    'returncode={!r}'.format(self.returncode)]
            if self.stdout is not None:
                args.append('stdout={!r}'.format(self.stdout))
            if self.stderr is not None:
                args.append('stderr={!r}'.format(self.stderr))
            return "{}({})".format(type(self).__name__, ', '.join(args))

        def check_returncode(self):
            """Raise CalledProcessError if the exit code is non-zero."""
            if self.returncode:
                raise subprocess.CalledProcessError(
                    self.returncode,
                    self.args,
                    self.stdout,
                    self.stderr,
                )
else:
    PY2 = False
    shlex_quote = shlex.quote
    subprocess_CompletedProcess = subprocess.CompletedProcess


class MissingPythonVersion(Exception):
    pass


def pip(python_version):
    if python_version == "2.6":
        return "pip.__main__"
    return "pip"


def run_command(command, **kwargs):
    print("  + {}".format(" ".join([shlex_quote(c) for c in command])))

    kwargs["stdin"] = subprocess.PIPE
    kwargs["stdout"] = subprocess.PIPE
    kwargs["stderr"] = subprocess.STDOUT
    if not PY2:
        kwargs.setdefault("encoding", sys.stdout.encoding)

    process = subprocess.Popen(command, **kwargs)
    try:
        # Close the stdin to make it an error for the subprocess to prompt.
        process.stdin.close()

        # Read lines off of the stdout and print them with a bit of whitespace
        # added to the front to differentiate it from this script's output.
        # Note: We're doing this instead of using process.communicate() because
        #       we want the lines of output as they are produced rather than
        #       when the process is finished.
        for line in process.stdout:
            print("      {}".format(line), end="")

        # Now that we've gotten here, the process should be finished so we'll
        # go ahead and fetch the return code.
        retcode = process.poll()

        if retcode:
            raise subprocess.CalledProcessError(retcode, command)

        return subprocess_CompletedProcess(command, retcode)
    finally:
        # If we switch to Py3, this can be replaced by a context manager, but
        # for now we'll copy Process.__exit__ to here so it works on Py2.

        if process.stdout:
            process.stdout.close()
        if process.stderr:
            process.stderr.close()
        try:  # Flushing a BufferedWriter may raise an error
            if process.stdin:
                process.stdin.close()
        finally:
            # Wait for the process to terminate, to avoid zombies.
            process.wait()


def ensure_packages(requirements, output_dir, pythons=None, virtualenv=None):
    if pythons is None:
        pythons = PYTHON_VERSIONS

    # Before we do anything, try and determine if the version of Pythons that
    # we're building for is installed on this machine.
    # Note: We do this here, before the main loop over the Pythons so we bail
    #       out early on any missing versions instead of do needless work.
    for python in sorted(pythons, reverse=True):
        try:
            subprocess.check_output(["python{}".format(python), "-c", ""])
        except FileNotFoundError:
            raise MissingPythonVersion(
                "Missing Python version {}.".format(python)
            )

    tmpdir = tempfile.mkdtemp()
    try:
        # We want to loop over every version of Python we support and download
        # or build wheels for them.
        first = False
        for python in sorted(pythons, reverse=True):
            print("Downloading Dependencies for {}".format(python))

            # Create our virtual environment.
            venv_path = os.path.abspath(os.path.join(tmpdir, python))
            python_path = os.path.join(venv_path, "bin", "python")
            run_command(["virtualenv", "-ppython{}".format(python), venv_path])

            # Ensure that we have the latest versions of all of our tools
            # installed in the virtual environment.
            run_command([
                python_path, "-m", pip(python), "install", "--upgrade",
                "pip"
            ])
            run_command([
                python_path, "-m", pip(python), "install", "--upgrade",
                "setuptools", "wheel",
            ])

            if not first:
                first = True
                # We need to download and bundle virtualenv, but we need it to
                # be the sdist since it won't actually be installed.
                run_command([
                    python_path, "-m", pip(python), "download",
                    "--no-cache-dir", "--no-binary=virtualenv",
                    "-d", output_dir, virtualenv,
                ])

            # Use the virtual environment to build our wheels, doing this
            # inside of a virtual environment ensures that we don't pollute the
            # outer environment.
            env = os.environ.copy()
            env["CC"] = "/bin/false"
            run_command(
                [
                    python_path, "-m", pip(python), "wheel", "-w", output_dir,
                    "--no-cache-dir"
                ] + requirements,
                env=env,
            )

            # We need to rename the PyYAML file, we've disabled the building of
            # it's C extension so it is now pure Python, HOWEVER, because of
            # the way it works wheel still thinks it is a binary file.
            # TODO: It'd be great if this wasn't required.
            for filename in os.listdir(output_dir):
                m = re.search(r"^PyYAML-([^-]+)-cp", filename)
                if m is not None:
                    shutil.move(
                        os.path.join(output_dir, filename),
                        os.path.join(
                            output_dir,
                            "PyYAML-{}-py{}-none-any.whl".format(
                                m.group(1),
                                python[0],
                            ),
                        ),
                    )
    finally:
        shutil.rmtree(tmpdir, ignore_errors=True)


def create_bootstrap_script(output_dir):
    print("Creating Bootstrap Script")
    install_script = os.path.join(
        os.path.dirname(os.path.abspath(__file__)), "install")
    shutil.copy(install_script, os.path.join(output_dir, "install"))


def zip_dir(bundle_dir, output):
    print("Creating Bundle")
    tmpdir, dirname = os.path.split(bundle_dir)
    with zipfile.ZipFile(output, "w", zipfile.ZIP_DEFLATED) as zfp:
        for root, dirnames, filenames in os.walk(bundle_dir):
            base = os.path.commonprefix([tmpdir, root])
            for filename in filenames:
                path = os.path.join(root, filename)
                zfp.write(path, arcname=os.path.relpath(path, base))


def create_bundled_installer(aws_cli=".", botocore=None, virtualenv=None,
                             pythons=None, output_dir="."):
    """
    Create a bundled installer.

    :param str aws_cli: The pip-like requirement for where awscli will be
                        installed from. Defaults to the current directory.
    :param str botocore: The pip-like requirement for where botocore will be
                         installed from. Defaults to PyPI.
    :param str virtualenv: The pip-like requirement or version number for what
                           virtualenv will be installed.
    :param list pythons: A list of Python versions the bundled installer should
                         be valid for. Versions should be strs of the form
                         X.Y. Defaults to 2.6, 2.7, and 3.3+.
    :param str output_dir: The directory to place the final awscli-bundle.zip
                           file when it has been created. Defaults to the
                           current directory.
    """
    requirements = [aws_cli]
    if botocore is not None:
        requirements.append(botocore)

    if virtualenv is None:
        virtualenv = VIRTUALENV_VERSION

    # This pattern relies on the fact that I know that virtualenv verisons will
    # pretty much always take this form. If one doesn't then a user will have
    # to explicitly use ``virtualenv==$VERSION`` rather than just ``$VERSION``.
    if re.search(r"^\d+(\.\d+)*$", virtualenv):
        virtualenv = "virtualenv=={}".format(virtualenv)

    tmpdir = tempfile.mkdtemp()
    try:
        bundle_dir = os.path.abspath(os.path.join(tmpdir, "awscli-bundle"))
        os.makedirs(bundle_dir)

        ensure_packages(
            requirements,
            virtualenv=virtualenv,
            output_dir=os.path.join(bundle_dir, "packages"),
            pythons=pythons,
        )

        create_bootstrap_script(bundle_dir)

        output = os.path.abspath(os.path.join(tmpdir, "awscli-bundle.zip"))
        zip_dir(bundle_dir, output)

        if not os.path.exists(output_dir):
            os.makedirs(output_dir)
        if os.path.exists(os.path.join(output_dir, os.path.basename(output))):
            os.remove(os.path.join(output_dir, os.path.basename(output)))
        shutil.move(output, output_dir)
    finally:
        shutil.rmtree(tmpdir, ignore_errors=True)

    print("Stored {} at {}".format(os.path.basename(output), output_dir))


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--aws-cli",
        metavar="REQUIREMENT",
        help="A pip requirement for what AWS CLI to install.",
        default=".",
    )
    parser.add_argument(
        "--botocore",
        metavar="REQUIREMENT",
        help="A pip requirement for what botocore to install.",
    )
    parser.add_argument(
        "--virtualenv",
        metavar="REQUIREMENT",
        help="A pip requirement for what virtualenv to use.",
        default=VIRTUALENV_VERSION,
    )
    parser.add_argument(
        "--python", "-p",
        metavar="Python",
        action="append",
        choices=PYTHON_VERSIONS,
        help=("A version of Python (X.Y) that this bundle will be valid for. "
              "Can be specified multiple times for multiple versions."),
    )
    parser.add_argument("--output-dir", default=".")

    args = parser.parse_args()

    try:
        create_bundled_installer(
            aws_cli=args.aws_cli,
            botocore=args.botocore,
            virtualenv=args.virtualenv,
            pythons=args.python,
            output_dir=args.output_dir,
        )
    except MissingPythonVersion as exc:
        sys.exit(str(exc))


if __name__ == "__main__":
    main()
